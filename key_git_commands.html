<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Kluczowe komendy programu **Git**</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
    <style>
        .task-list-item {
            list-style-type: none;
        }
        .task-list-item-checkbox {
            margin-left: -20px;
            vertical-align: middle;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
            font-size: 14px;
            line-height: 1.6;
        }
        .command {
            border-bottom: 1px solid lightgrey;
            margin-bottom: 64px;
        }
    </style>
</head>

<body class="vscode-light">

    <h1> Kluczowe komendy programu <strong>Git</strong> </h1>
    <section class="command">
        <h3> <code>git config --global user.name &quot;&quot;</code> </h3>
        <p>
            Komenda zmieniająca naszą <strong>lokalną</strong> nazwę w aplikacji Git. Nazwa ta służy do podpisywania commitów wysyłanych do bazy głównej, nie jest w żaden sposób powiązana z naszą nazwą na przykład na GitHubie. Trzeba zaznaczyć, że zmiana nazwy nie spowoduje zmiany w poprzednich commitach, które zostały wysłane na serwer główny, a jedynie wpłynie na każde przyszłe commity. Parametry:
            <ul>
                <li>
                    --global: ustawia nazwę dla każdego repozytorium, nad którym pracujemy. Bez tego parametru, zmienimy jedynie nazwę w repozytorium, w którym się znajdujemy
                </li>
                <li>
                    &quot;&quot; - w cudzysłowie podajemy swoją nazwę
                    Dodatkowo możemy jeszcze powiązać adres e-mail z gitem zastępując parametr <code>user.name</code> parametrem <code>user.email</code>
                </li>
            </ul>
        </p>
    </section>

    <section class="command">
        <h3> <code>git reset HEAD</code> </h3>
        <p>
            Wywołanie tej komendy usuwa <strong>wszystkie</strong> pliki z poczekalni (pliki staged) na aktualnie używanym branch'u. Przydatne, gdy chcemy zrobić pull i wiemy, że pull ten nie zmieni plików, które mamy aktualnie w poczekalni. (by zrobić pull <strong>nie możemy</strong> mieć plików w poczekalni)
        </p>

        <p>
            Przykład użycia:
            <ol>
                <li>
                    Zrobić jakieś zmiany w repozytorium w paru plikach.
                </li>

                <li>
                    <code>git add . </code>
                </li>

                <li>
                    <code>git status</code>
                </li>

                <li>
                    <code>git reset HEAD</code>
                </li>

                <li>
                    <code>git status</code>
                </li>
        </p>

        <p>
            (Na marginesie: <code>git reset HEAD <em>nazwa_pliku</em> </code> wycofuje z poczekalni <strong>tylko</strong> plik podany jako argument.)
        </p>


        <p>
            Źródło: <a href="https://git-scm.com/book/pl/v2/Podstawy-Gita-Cofanie-zmian">https://git-scm.com/book/pl/v2/Podstawy-Gita-Cofanie-zmian</a>
        </p>

    </section>

    <section class="command">
        <h3><code>gitk -all</code></h3>
        <p>
            Wyświetla zmiany w repozytorium lub w wybranych commitach. Obejmuje to wizualizację wykresu commitów, pokazanie informacji związanych z każdym commitów oraz plików w drzewach każdej wersji.<br>
            Opcja <strong>--all</strong> pokazuje wszystkie referncje (gałęzie, tagi itp.).
        </p>
    </section>

    <section class="command">
        <h3><code>git branch --merged</code></h3>
        <p>
            Komenda git branch bez parametrów umożliwia użytkownikowi sprawdzenie użytkownikowi jego aktualnych gałęzi. Gałąź przy której znajduje się znak &quot;&ast;&quot; Oznacza, że jest to gałąź na której użytkownik aktualnie pracuje.
	    <ul>
	    <li> --merged: wyświetla które gałęzie już zostały zmergowane z gałęzią na której użytkownik aktualnie pracował. Gałęzie które nie posiadają &quot;&ast;&quot; są bezpieczne do usunięcia, gdyż zmiany z nich zostały już dodane do 
		    aktualnej gałęzi.</li>
	    <ul>
        </p>
    </section>

    <section class="command">
        <h3><code>git branch &quot;branch&quot; &quot;commit hash&quot;</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section>

    <section class="command">
        <h3><code>git pull &quot;remote&quot; &quot;branch&quot;</code></h3>
        <p> 
        Uruchomienie <code>git pull</code> rozpoczyna ściągnięcie danych z serwera oraz próbuje automatycznie scalić zmiany z kodem znajdującym się lokalnie. Jest to połączenie dwóch komend: <code>git fetch</code> - ściągnięcie danych i <code>git merge</code> - połączenie zmian. Nie modyfikując podczas pracy repozytorium i gałęzi wystarczy wpisać samo <code>git pull</code>. Domyślne wartości repozytorium i brancha zostaną odczytane z konfiguracji gita (ustawienia "remote" oraz "merge"). <br> 
        Parametry:
		    <ul>
    			<li>"remote" to nazwa repozytorium, na przykład gdy stworzyliśmy je poprzez sklonowanie, oryginalne repozytorium będzie miało domyślnie nazwę <strong>origin</strong>.</li>
    			<li>"branch" to nazwa gałęzi z której mają być pobrane zmiany. Automatycznie główny branch to <strong>master</strong>.</li>
		    </ul>
        </p>
    </section>

    <section class="command">
        <h3><code>git config --global user.email &quot;&quot;</code></h3>
        <p>
            <li>Konfiguracja adresu mailowego. Jest to istotne ponieważ każda operacja zatwierdzona w Git korzysta z tej informacji.</li>
            <li>
                  $ git config --global user.email jankowalski@example.com
            </li>
            <li>Jeżeli użyjemy --global to konfiguracja bedzie dokonana jednorazowo. Git za każdym razem będzie z tej konfiguracji kozystał. </li>
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git diff --staged</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git checkout -b &quot;branch&quot;</code></h3>
        <p>
			Gałęzie (branch'e) są używane do rozwijania poszczegółnych funkcjonalności.
			Branch <b><code>master</code></b> jest domyślną gałęzią przy tworzeniu repozytorium, 
			najczęszczej na tej gałęzi są wyłącznie gotowe źródła projektów.			
        </p>
		<p>
			Do tworzenia nowego branch'u jest używane polecenie 
		</p>	
		<pre>
<!--		--> git chceckout -b &ltnazwa-nowego-branch'u&gt &ltnazwa-branch'u-początkowego&gt
		</pre>
		<p>
			Przykład użycia
		</p>	
		<pre>
<!--		--> git chceckout -b feature-logowanie master
		</pre>
    </section class="command">

    <section class="command">
        <h3><code>git log --graph --all</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section>

    <section class="command">
        <h3><code>git branch -d &quot;branch&quot;</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section>

    <section class="command">
        <h3><code>git fetch &quot;remote&quot; &quot;branch&quot;</code></h3>
        <p>
	   <ul> 
		<li>
		   Komenda fetch pobiera commity, pliki i odnosi się ze zdalnego repozytorium do naszego lokalnego.
		</li>
		<li>
		   git fetch < remote > sprowadza wszystkie branche z repozytorium. Pobiera również wszsytkie wymagane commity i pliki z innych repozytoriów.          
		</li>
		<li>
	           git fetch < remote > <  branch > robi to samo co powyższa komenda, ale sprowadza tylko określony branch.
	        </li>
		<li>
		   Przykład użycia: git fetch PRA2018-2019 JSONandXMLStart
		</li>	  
	    </ul>	
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git config --global color.ui true</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git commit &quot;filename&quot;</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section>

    <section class="command">
        <h3><code>git branch -v</code></h3>
        <p>
            Wyświetla listę gałęzi wraz z dodatkowymi informacjami.
            <ul>
                <li>
                    Znak "*" przed nazwą gałęzi oznacza naszą obecną gałąź HEAD. 
                </li>
                <li>
                    Informacja na której gałęzi jest bazowana.
                </li>
                <li>
                    Ostatni commit na danej gałęzi.
                </li>
            </ul>
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git push &quot;remote&quot; &quot;branch&quot;</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git log &quot;branch&quot; --not &quot;branch&quot;</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section>

    <section class="command">
        <h3><code>git bisect (start, bad, good, reset)</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git commit -a -m &quot;&quot;</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section>

    <section class="command">
        <h3><code>git add .</code></h3>
        <p>
            Komenda dodaje wszystkie modyfikowane i nowe pliki z folderu w ktorym sie aktualnie znajdujemy do "staging area", czyli dodaje pliki aby mozna bylo je commitowac.
        </p>
    </section>

    <section class="command">
        <h3><code>git checkout &quot;branch&quot;</code></h3>
        <p>
            Komenda pozwalająca nawigować między branchami utworzonymi przez komendę &quot;branch&quot;. Zmiana &quot;brancha&quot; updatuje pliki w katalogu roboczym, tak aby zgadzały się z plikami na branchu, na który przechodzimy. Wszystkie commity są również rejestrowane na branchu, na który przeszliśmy.
            <br /><strong>Zastosowanie:</strong>
            <ul>
                <li>
                    Takie podejście umożliwia np. eksperymentowanie z kodem, bez obawy zepsucia głównej wersji
                </li>
            </ul>
            <strong>Przykłady:</strong>
            <ul>
                <li>
                    git checkout &lt;test_branch&gt;  - przejście z obecnego brancha na test_branch
                </li>
                <li>
                    git checkout -b &lt;new_branch&gt;  - utworzenie nowego brancha i przejście z obecnego brancha na new_branch
                </li>
            </ul>
        </p>   
    </section class="command">

    <section class="command">
        <h3><code>git remote add &quot;remote_name&quot; &quot;git url&quot;</code></h3>
        <p>
            <!-- describe here -->
        </p>
    </section class="command">

    <section class="command">
        <h3><code>git blame -C &quot;filename&quot;</code></h3>
        <p>
            W ogólności komenda git-blame informuje nas o tym, w której poprawce (commit) i jaki autor zmodyfikował konkretne linie w danym pliku. Opcja -C może być użyta trzy razy.
			<ul>
				<li>
					 Użyta raz wykrywa linie przeniesione, bądź skopiowane z innych plików, które były modyfikowane wewnątrz tej samej poprawki. Opcja jest szczególnie użyteczna w przypadku, gdy dokonujemy reorganizacji kodu i przenosimy jego fragmenty między różnymi plikami.
				</li>
				<li>
					Użyta podwójnie, dodatkowo szuka linii skopiowanych z innych plików, działa tylko dla poprawki w której stworzono plik.
				</li>
				<li>
					Użyta potrójnie, dodatkowo szuka linii skopiowanych z innycy plików we wszystkich poprawkach.
				</li>
				<li>
					Przykład użycia: "git blame -C -C -C dest"
				</li>
			</ul>
        </p>    
    </section class="command">

    <section class="command">
        <h3><code>git branch &quot;name&quot;</code></h3>
        <p>
            Tworzy nową <strong>gałąź</strong> projektu.
            <ul>
                <li>
                    Dodatkowe gałęzie projektu są przydatne do tworzenia różnych wersji produktu, aby
                    następnie sprawnie pokazać klientowi dwie odmienne wersje i dowiedzieć się która bardziej mu odpowiada.
                </li>
                <li>
                    Przykład użycia: "git branch nazwaNowegoBrancha"
                </li>
            </ul>


        </p>
    </section class="command">


    <footer>
        <p>
            <strong>Źródła: 
            <ul>
                <li><a href="https://help.github.com/en/github/using-git/setting-your-username-in-git">https://help.github.com/en/github/using-git/setting-your-username-in-git</a></li>
                <li><a href="https://git-scm.com/docs/git-pull">https://git-scm.com/docs/git-pull</a></li>
            </ul>
		    </strong>        
	</p>
    </footer>
</body>

</html>
